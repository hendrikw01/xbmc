diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/allcodecs.c ffmpeg-2.4.6-Helix/libavcodec/allcodecs.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/allcodecs.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/allcodecs.c	2015-04-12 13:47:40.666645526 +0200
@@ -68,60 +68,61 @@
 void avcodec_register_all(void)
 {
     static int initialized;
 
     if (initialized)
         return;
     initialized = 1;
 
     /* hardware accelerators */
     REGISTER_HWACCEL(H263_VAAPI,        h263_vaapi);
     REGISTER_HWACCEL(H263_VDPAU,        h263_vdpau);
     REGISTER_HWACCEL(H264_DXVA2,        h264_dxva2);
     REGISTER_HWACCEL(H264_VAAPI,        h264_vaapi);
     REGISTER_HWACCEL(H264_VDA,          h264_vda);
     REGISTER_HWACCEL(H264_VDA_OLD,      h264_vda_old);
     REGISTER_HWACCEL(H264_VDPAU,        h264_vdpau);
     REGISTER_HWACCEL(MPEG1_XVMC,        mpeg1_xvmc);
     REGISTER_HWACCEL(MPEG1_VDPAU,       mpeg1_vdpau);
     REGISTER_HWACCEL(MPEG2_XVMC,        mpeg2_xvmc);
     REGISTER_HWACCEL(MPEG2_DXVA2,       mpeg2_dxva2);
     REGISTER_HWACCEL(MPEG2_VAAPI,       mpeg2_vaapi);
     REGISTER_HWACCEL(MPEG2_VDPAU,       mpeg2_vdpau);
     REGISTER_HWACCEL(MPEG4_VAAPI,       mpeg4_vaapi);
     REGISTER_HWACCEL(MPEG4_VDPAU,       mpeg4_vdpau);
     REGISTER_HWACCEL(VC1_DXVA2,         vc1_dxva2);
     REGISTER_HWACCEL(VC1_VAAPI,         vc1_vaapi);
     REGISTER_HWACCEL(VC1_VDPAU,         vc1_vdpau);
     REGISTER_HWACCEL(WMV3_DXVA2,        wmv3_dxva2);
     REGISTER_HWACCEL(WMV3_VAAPI,        wmv3_vaapi);
     REGISTER_HWACCEL(WMV3_VDPAU,        wmv3_vdpau);
+    REGISTER_HWACCEL(MSMPEG4V3_VDPAU,   msmpeg4v3_vdpau);
 
     /* video codecs */
     REGISTER_ENCODER(A64MULTI,          a64multi);
     REGISTER_ENCODER(A64MULTI5,         a64multi5);
     REGISTER_DECODER(AASC,              aasc);
     REGISTER_DECODER(AIC,               aic);
     REGISTER_ENCDEC (ALIAS_PIX,         alias_pix);
     REGISTER_ENCDEC (AMV,               amv);
     REGISTER_DECODER(ANM,               anm);
     REGISTER_DECODER(ANSI,              ansi);
     REGISTER_ENCDEC (ASV1,              asv1);
     REGISTER_ENCDEC (ASV2,              asv2);
     REGISTER_DECODER(AURA,              aura);
     REGISTER_DECODER(AURA2,             aura2);
     REGISTER_ENCDEC (AVRP,              avrp);
     REGISTER_DECODER(AVRN,              avrn);
     REGISTER_DECODER(AVS,               avs);
     REGISTER_ENCDEC (AVUI,              avui);
     REGISTER_ENCDEC (AYUV,              ayuv);
     REGISTER_DECODER(BETHSOFTVID,       bethsoftvid);
     REGISTER_DECODER(BFI,               bfi);
     REGISTER_DECODER(BINK,              bink);
     REGISTER_ENCDEC (BMP,               bmp);
     REGISTER_DECODER(BMV_VIDEO,         bmv_video);
     REGISTER_DECODER(BRENDER_PIX,       brender_pix);
     REGISTER_DECODER(C93,               c93);
     REGISTER_DECODER(CAVS,              cavs);
     REGISTER_DECODER(CDGRAPHICS,        cdgraphics);
     REGISTER_DECODER(CDXL,              cdxl);
     REGISTER_ENCDEC (CINEPAK,           cinepak);
@@ -183,60 +184,62 @@
     REGISTER_DECODER(INTERPLAY_VIDEO,   interplay_video);
     REGISTER_ENCDEC (JPEG2000,          jpeg2000);
     REGISTER_ENCDEC (JPEGLS,            jpegls);
     REGISTER_DECODER(JV,                jv);
     REGISTER_DECODER(KGV1,              kgv1);
     REGISTER_DECODER(KMVC,              kmvc);
     REGISTER_DECODER(LAGARITH,          lagarith);
     REGISTER_ENCODER(LJPEG,             ljpeg);
     REGISTER_DECODER(LOCO,              loco);
     REGISTER_DECODER(MDEC,              mdec);
     REGISTER_DECODER(MIMIC,             mimic);
     REGISTER_ENCDEC (MJPEG,             mjpeg);
     REGISTER_DECODER(MJPEGB,            mjpegb);
     REGISTER_DECODER(MMVIDEO,           mmvideo);
     REGISTER_DECODER(MOTIONPIXELS,      motionpixels);
 #if FF_API_XVMC
     REGISTER_DECODER(MPEG_XVMC,         mpeg_xvmc);
 #endif /* FF_API_XVMC */
     REGISTER_ENCDEC (MPEG1VIDEO,        mpeg1video);
     REGISTER_ENCDEC (MPEG2VIDEO,        mpeg2video);
     REGISTER_ENCDEC (MPEG4,             mpeg4);
     REGISTER_DECODER(MPEG4_CRYSTALHD,   mpeg4_crystalhd);
     REGISTER_DECODER(MPEG4_VDPAU,       mpeg4_vdpau);
     REGISTER_DECODER(MPEGVIDEO,         mpegvideo);
     REGISTER_DECODER(MPEG_VDPAU,        mpeg_vdpau);
     REGISTER_DECODER(MPEG1_VDPAU,       mpeg1_vdpau);
     REGISTER_DECODER(MPEG2_CRYSTALHD,   mpeg2_crystalhd);
     REGISTER_DECODER(MSA1,              msa1);
     REGISTER_DECODER(MSMPEG4_CRYSTALHD, msmpeg4_crystalhd);
     REGISTER_DECODER(MSMPEG4V1,         msmpeg4v1);
+    REGISTER_DECODER(MSMPEG4V1_VDPAU,   msmpeg4v1_vdpau);
+    REGISTER_DECODER(MSMPEG4V3_VDPAU,   msmpeg4v3_vdpau);
     REGISTER_ENCDEC (MSMPEG4V2,         msmpeg4v2);
     REGISTER_ENCDEC (MSMPEG4V3,         msmpeg4v3);
     REGISTER_DECODER(MSRLE,             msrle);
     REGISTER_DECODER(MSS1,              mss1);
     REGISTER_DECODER(MSS2,              mss2);
     REGISTER_ENCDEC (MSVIDEO1,          msvideo1);
     REGISTER_DECODER(MSZH,              mszh);
     REGISTER_DECODER(MTS2,              mts2);
     REGISTER_DECODER(MVC1,              mvc1);
     REGISTER_DECODER(MVC2,              mvc2);
     REGISTER_DECODER(MXPEG,             mxpeg);
     REGISTER_DECODER(NUV,               nuv);
     REGISTER_DECODER(PAF_VIDEO,         paf_video);
     REGISTER_ENCDEC (PAM,               pam);
     REGISTER_ENCDEC (PBM,               pbm);
     REGISTER_ENCDEC (PCX,               pcx);
     REGISTER_ENCDEC (PGM,               pgm);
     REGISTER_ENCDEC (PGMYUV,            pgmyuv);
     REGISTER_DECODER(PICTOR,            pictor);
     REGISTER_ENCDEC (PNG,               png);
     REGISTER_ENCDEC (PPM,               ppm);
     REGISTER_ENCDEC (PRORES,            prores);
     REGISTER_ENCODER(PRORES_AW,         prores_aw);
     REGISTER_ENCODER(PRORES_KS,         prores_ks);
     REGISTER_DECODER(PRORES_LGPL,       prores_lgpl);
     REGISTER_DECODER(PTX,               ptx);
     REGISTER_DECODER(QDRAW,             qdraw);
     REGISTER_DECODER(QPEG,              qpeg);
     REGISTER_ENCDEC (QTRLE,             qtrle);
     REGISTER_ENCDEC (R10K,              r10k);
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/avcodec.h ffmpeg-2.4.6-Helix/libavcodec/avcodec.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/avcodec.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/avcodec.h	2015-04-12 13:47:40.686644914 +0200
@@ -100,60 +100,61 @@
  * 1. no value of a existing codec ID changes (that would break ABI),
  * 2. Give it a value which when taken as ASCII is recognized uniquely by a human as this specific codec.
  *    This ensures that 2 forks can independently add AVCodecIDs without producing conflicts.
  *
  * After adding new codec IDs, do not forget to add an entry to the codec
  * descriptor list and bump libavcodec minor version.
  */
 enum AVCodecID {
     AV_CODEC_ID_NONE,
 
     /* video codecs */
     AV_CODEC_ID_MPEG1VIDEO,
     AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
 #if FF_API_XVMC
     AV_CODEC_ID_MPEG2VIDEO_XVMC,
 #endif /* FF_API_XVMC */
     AV_CODEC_ID_H261,
     AV_CODEC_ID_H263,
     AV_CODEC_ID_RV10,
     AV_CODEC_ID_RV20,
     AV_CODEC_ID_MJPEG,
     AV_CODEC_ID_MJPEGB,
     AV_CODEC_ID_LJPEG,
     AV_CODEC_ID_SP5X,
     AV_CODEC_ID_JPEGLS,
     AV_CODEC_ID_MPEG4,
     AV_CODEC_ID_RAWVIDEO,
     AV_CODEC_ID_MSMPEG4V1,
     AV_CODEC_ID_MSMPEG4V2,
     AV_CODEC_ID_MSMPEG4V3,
+    AV_CODEC_ID_MSMPEG4V4,
     AV_CODEC_ID_WMV1,
     AV_CODEC_ID_WMV2,
     AV_CODEC_ID_H263P,
     AV_CODEC_ID_H263I,
     AV_CODEC_ID_FLV1,
     AV_CODEC_ID_SVQ1,
     AV_CODEC_ID_SVQ3,
     AV_CODEC_ID_DVVIDEO,
     AV_CODEC_ID_HUFFYUV,
     AV_CODEC_ID_CYUV,
     AV_CODEC_ID_H264,
     AV_CODEC_ID_INDEO3,
     AV_CODEC_ID_VP3,
     AV_CODEC_ID_THEORA,
     AV_CODEC_ID_ASV1,
     AV_CODEC_ID_ASV2,
     AV_CODEC_ID_FFV1,
     AV_CODEC_ID_4XM,
     AV_CODEC_ID_VCR1,
     AV_CODEC_ID_CLJR,
     AV_CODEC_ID_MDEC,
     AV_CODEC_ID_ROQ,
     AV_CODEC_ID_INTERPLAY_VIDEO,
     AV_CODEC_ID_XAN_WC3,
     AV_CODEC_ID_XAN_WC4,
     AV_CODEC_ID_RPZA,
     AV_CODEC_ID_CINEPAK,
     AV_CODEC_ID_WS_VQA,
     AV_CODEC_ID_MSRLE,
     AV_CODEC_ID_MSVIDEO1,
@@ -1452,63 +1453,65 @@
      */
     int me_method;
 
     /**
      * If non NULL, 'draw_horiz_band' is called by the libavcodec
      * decoder to draw a horizontal band. It improves cache usage. Not
      * all codecs can do that. You must check the codec capabilities
      * beforehand.
      * When multithreading is used, it may be called from multiple threads
      * at the same time; threads might draw different parts of the same AVFrame,
      * or multiple AVFrames, and there is no guarantee that slices will be drawn
      * in order.
      * The function is also used by hardware acceleration APIs.
      * It is called at least once during frame decoding to pass
      * the data needed for hardware render.
      * In that mode instead of pixel data, AVFrame points to
      * a structure specific to the acceleration API. The application
      * reads the structure and can change some fields to indicate progress
      * or mark state.
      * - encoding: unused
      * - decoding: Set by user.
      * @param height the height of the slice
      * @param y the y position of the slice
      * @param type 1->top field, 2->bottom field, 3->frame
      * @param offset offset into the AVFrame.data from which the slice should be read
      */
     void (*draw_horiz_band)(struct AVCodecContext *s,
                             const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
                             int y, int type, int height);
 
+    int (*set_video_header)(struct AVCodecContext *avctx, const uint32_t id);
+
     /**
      * callback to negotiate the pixelFormat
-     * @param fmt is the list of formats which are supported by the codec,
+     * @param fmt is the list of formats which are supported by the codec,F
      * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
      * The first is always the native one.
      * @return the chosen format
      * - encoding: unused
      * - decoding: Set by user, if not set the native format will be chosen.
      */
     enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
 
     /**
      * maximum number of B-frames between non-B-frames
      * Note: The output will be delayed by max_b_frames+1 relative to the input.
      * - encoding: Set by user.
      * - decoding: unused
      */
     int max_b_frames;
 
     /**
      * qscale factor between IP and B-frames
      * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
      * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
      * - encoding: Set by user.
      * - decoding: unused
      */
     float b_quant_factor;
 
     /** obsolete FIXME remove */
     int rc_strategy;
 #define FF_RC_STRATEGY_XVID 1
 
     int b_frame_strategy;
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/h263dec.c ffmpeg-2.4.6-Helix/libavcodec/h263dec.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/h263dec.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/h263dec.c	2015-11-25 21:45:58.896907707 +0100
@@ -120,97 +120,101 @@
     if (avctx->codec->id != AV_CODEC_ID_H263 &&
         avctx->codec->id != AV_CODEC_ID_H263P &&
         avctx->codec->id != AV_CODEC_ID_MPEG4) {
         ff_mpv_idct_init(s);
         if ((ret = ff_mpv_common_init(s)) < 0)
             return ret;
     }
 
     ff_h263dsp_init(&s->h263dsp);
     ff_qpeldsp_init(&s->qdsp);
     ff_h263_decode_init_vlc();
 
     return 0;
 }
 
 av_cold int ff_h263_decode_end(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx->priv_data;
 
     ff_mpv_common_end(s);
     return 0;
 }
 
 /**
  * Return the number of bytes consumed for building the current frame.
  */
 static int get_consumed_bytes(MpegEncContext *s, int buf_size)
 {
     int pos = (get_bits_count(&s->gb) + 7) >> 3;
 
-    if (s->divx_packed || s->avctx->hwaccel) {
+    if(s->divx_packed || (s->avctx->hwaccel &&
+         !(s->codec_id == AV_CODEC_ID_MSMPEG4V1 || 
+           s->codec_id == AV_CODEC_ID_MSMPEG4V2 ||
+           s->codec_id == AV_CODEC_ID_MSMPEG4V3 ||
+           s->codec_id == AV_CODEC_ID_MSMPEG4V4))) {
         /* We would have to scan through the whole buf to handle the weird
          * reordering ... */
         return buf_size;
     } else if (s->flags & CODEC_FLAG_TRUNCATED) {
         pos -= s->parse_context.last_index;
         // padding is not really read so this might be -1
         if (pos < 0)
             pos = 0;
         return pos;
     } else {
         // avoid infinite loops (maybe not needed...)
         if (pos == 0)
             pos = 1;
         // oops ;)
         if (pos + 10 > buf_size)
             pos = buf_size;
 
         return pos;
     }
 }
 
 static int decode_slice(MpegEncContext *s)
 {
     const int part_mask = s->partitioned_frame
                           ? (ER_AC_END | ER_AC_ERROR) : 0x7F;
     const int mb_size   = 16 >> s->avctx->lowres;
     int ret;
 
     s->last_resync_gb   = s->gb;
     s->first_slice_line = 1;
     s->resync_mb_x      = s->mb_x;
     s->resync_mb_y      = s->mb_y;
 
     ff_set_qscale(s, s->qscale);
 
-    if (s->avctx->hwaccel) {
+    if (s->avctx->hwaccel /* && !s->msmpeg4_version */) {
         const uint8_t *start = s->gb.buffer + get_bits_count(&s->gb) / 8;
         ret = s->avctx->hwaccel->decode_slice(s->avctx, start, s->gb.buffer_end - start);
         // ensure we exit decode loop
         s->mb_y = s->mb_height;
         return ret;
     }
 
     if (s->partitioned_frame) {
         const int qscale = s->qscale;
 
         if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4)
             if ((ret = ff_mpeg4_decode_partitions(s->avctx->priv_data)) < 0)
                 return ret;
 
         /* restore variables which were modified */
         s->first_slice_line = 1;
         s->mb_x             = s->resync_mb_x;
         s->mb_y             = s->resync_mb_y;
         ff_set_qscale(s, qscale);
     }
 
     for (; s->mb_y < s->mb_height; s->mb_y++) {
         /* per-row end of slice checks */
         if (s->msmpeg4_version) {
             if (s->resync_mb_y + s->slice_height == s->mb_y) {
                 ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,
                                 s->mb_x - 1, s->mb_y, ER_MB_END);
 
                 return 0;
             }
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/mpeg12dec.c ffmpeg-2.4.6-Helix/libavcodec/mpeg12dec.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/mpeg12dec.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/mpeg12dec.c	2015-11-27 23:23:41.214933363 +0100
@@ -1161,73 +1161,73 @@
     err = ff_mpeg_update_thread_context(avctx, avctx_from);
     if (err)
         return err;
 
     if (!ctx->mpeg_enc_ctx_allocated)
         memcpy(s + 1, s1 + 1, sizeof(Mpeg1Context) - sizeof(MpegEncContext));
 
     if (!(s->pict_type == AV_PICTURE_TYPE_B || s->low_delay))
         s->picture_number++;
 
     return 0;
 }
 
 static void quant_matrix_rebuild(uint16_t *matrix, const uint8_t *old_perm,
                                  const uint8_t *new_perm)
 {
     uint16_t temp_matrix[64];
     int i;
 
     memcpy(temp_matrix, matrix, 64 * sizeof(uint16_t));
 
     for (i = 0; i < 64; i++)
         matrix[new_perm[i]] = temp_matrix[old_perm[i]];
 }
 
 static const enum AVPixelFormat mpeg1_hwaccel_pixfmt_list_420[] = {
 #if CONFIG_MPEG1_XVMC_HWACCEL
     AV_PIX_FMT_XVMC,
 #endif
 #if CONFIG_MPEG1_VDPAU_HWACCEL
-    AV_PIX_FMT_VDPAU_MPEG1,
+//    AV_PIX_FMT_VDPAU_MPEG1,
     AV_PIX_FMT_VDPAU,
 #endif
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_NONE
 };
 
 static const enum AVPixelFormat mpeg2_hwaccel_pixfmt_list_420[] = {
 #if CONFIG_MPEG2_XVMC_HWACCEL
     AV_PIX_FMT_XVMC,
 #endif
 #if CONFIG_MPEG2_VDPAU_HWACCEL
-    AV_PIX_FMT_VDPAU_MPEG2,
+//    AV_PIX_FMT_VDPAU_MPEG2,
     AV_PIX_FMT_VDPAU,
 #endif
 #if CONFIG_MPEG2_DXVA2_HWACCEL
     AV_PIX_FMT_DXVA2_VLD,
 #endif
 #if CONFIG_MPEG2_VAAPI_HWACCEL
     AV_PIX_FMT_VAAPI_VLD,
 #endif
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_NONE
 };
 
 static const enum AVPixelFormat mpeg12_pixfmt_list_422[] = {
     AV_PIX_FMT_YUV422P,
     AV_PIX_FMT_NONE
 };
 
 static const enum AVPixelFormat mpeg12_pixfmt_list_444[] = {
     AV_PIX_FMT_YUV444P,
     AV_PIX_FMT_NONE
 };
 
 static inline int uses_vdpau(AVCodecContext *avctx) {
     return avctx->pix_fmt == AV_PIX_FMT_VDPAU_MPEG1 || avctx->pix_fmt == AV_PIX_FMT_VDPAU_MPEG2;
 }
 
 static enum AVPixelFormat mpeg_get_pixelformat(AVCodecContext *avctx)
 {
     Mpeg1Context *s1  = avctx->priv_data;
     MpegEncContext *s = &s1->mpeg_enc_ctx;
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/mpeg4videodec.c ffmpeg-2.4.6-Helix/libavcodec/mpeg4videodec.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/mpeg4videodec.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/mpeg4videodec.c	2015-11-27 23:23:41.504923953 +0100
@@ -5,60 +5,61 @@
  *
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #define UNCHECKED_BITSTREAM_READER 1
 
 #include "libavutil/opt.h"
 #include "error_resilience.h"
 #include "idctdsp.h"
 #include "internal.h"
 #include "mpegutils.h"
 #include "mpegvideo.h"
 #include "mpeg4video.h"
 #include "h263.h"
 #include "thread.h"
 #include "xvididct.h"
+#include "vdpau.h"
 
 /* The defines below define the number of bits that are read at once for
  * reading vlc values. Changing these may improve speed and data cache needs
  * be aware though that decreasing them may need the number of stages that is
  * passed to get_vlc* to be increased. */
 #define SPRITE_TRAJ_VLC_BITS 6
 #define DC_VLC_BITS 9
 #define MB_TYPE_B_VLC_BITS 4
 
 static VLC dc_lum, dc_chrom;
 static VLC sprite_trajectory;
 static VLC mb_type_b_vlc;
 
 static const int mb_type_b_map[4] = {
     MB_TYPE_DIRECT2 | MB_TYPE_L0L1,
     MB_TYPE_L0L1    | MB_TYPE_16x16,
     MB_TYPE_L1      | MB_TYPE_16x16,
     MB_TYPE_L0      | MB_TYPE_16x16,
 };
 
 /**
  * Predict the ac.
  * @param n block index (0-3 are luma, 4-5 are chroma)
  * @param dir the ac prediction direction
  */
 void ff_mpeg4_pred_ac(MpegEncContext *s, int16_t *block, int n, int dir)
 {
     int i;
     int16_t *ac_val, *ac_val1;
     int8_t *const qscale_table = s->current_picture.qscale_table;
@@ -2563,60 +2564,63 @@
             else if (startcode == 0x1BA)
                 av_log(s->avctx, AV_LOG_DEBUG, "FBA Object start");
             else if (startcode == 0x1BB)
                 av_log(s->avctx, AV_LOG_DEBUG, "FBA Object Plane start");
             else if (startcode == 0x1BC)
                 av_log(s->avctx, AV_LOG_DEBUG, "Mesh Object start");
             else if (startcode == 0x1BD)
                 av_log(s->avctx, AV_LOG_DEBUG, "Mesh Object Plane start");
             else if (startcode == 0x1BE)
                 av_log(s->avctx, AV_LOG_DEBUG, "Still Texture Object start");
             else if (startcode == 0x1BF)
                 av_log(s->avctx, AV_LOG_DEBUG, "Texture Spatial Layer start");
             else if (startcode == 0x1C0)
                 av_log(s->avctx, AV_LOG_DEBUG, "Texture SNR Layer start");
             else if (startcode == 0x1C1)
                 av_log(s->avctx, AV_LOG_DEBUG, "Texture Tile start");
             else if (startcode == 0x1C2)
                 av_log(s->avctx, AV_LOG_DEBUG, "Texture Shape Layer start");
             else if (startcode == 0x1C3)
                 av_log(s->avctx, AV_LOG_DEBUG, "stuffing start");
             else if (startcode <= 0x1C5)
                 av_log(s->avctx, AV_LOG_DEBUG, "reserved");
             else if (startcode <= 0x1FF)
                 av_log(s->avctx, AV_LOG_DEBUG, "System start");
             av_log(s->avctx, AV_LOG_DEBUG, " at %d\n", get_bits_count(gb));
         }
 
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if (decode_vol_header(ctx, gb) < 0)
                 return -1;
+            if(s->avctx->set_video_header) {
+               s->avctx->set_video_header(s->avctx, VDP_MPEG4_VOL_HEADER);
+            }
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
             mpeg4_decode_profile_level(s, gb);
         } else if (startcode == VOP_STARTCODE) {
             break;
         }
 
         align_get_bits(gb);
         startcode = 0xff;
     }
 
 end:
     if (s->flags & CODEC_FLAG_LOW_DELAY)
         s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
 
     return decode_vop_header(ctx, gb);
 }
 
 av_cold void ff_mpeg4videodec_static_init(void) {
     static int done = 0;
 
     if (!done) {
         ff_init_rl(&ff_mpeg4_rl_intra, ff_mpeg4_static_rl_table_store[0]);
         ff_init_rl(&ff_rvlc_rl_inter, ff_mpeg4_static_rl_table_store[1]);
         ff_init_rl(&ff_rvlc_rl_intra, ff_mpeg4_static_rl_table_store[2]);
         INIT_VLC_RL(ff_mpeg4_rl_intra, 554);
@@ -2732,75 +2736,89 @@
     { FF_PROFILE_MPEG4_CORE,                      "Core Profile" },
     { FF_PROFILE_MPEG4_MAIN,                      "Main Profile" },
     { FF_PROFILE_MPEG4_N_BIT,                     "N-bit Profile" },
     { FF_PROFILE_MPEG4_SCALABLE_TEXTURE,          "Scalable Texture Profile" },
     { FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION,     "Simple Face Animation Profile" },
     { FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE,    "Basic Animated Texture Profile" },
     { FF_PROFILE_MPEG4_HYBRID,                    "Hybrid Profile" },
     { FF_PROFILE_MPEG4_ADVANCED_REAL_TIME,        "Advanced Real Time Simple Profile" },
     { FF_PROFILE_MPEG4_CORE_SCALABLE,             "Code Scalable Profile" },
     { FF_PROFILE_MPEG4_ADVANCED_CODING,           "Advanced Coding Profile" },
     { FF_PROFILE_MPEG4_ADVANCED_CORE,             "Advanced Core Profile" },
     { FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE, "Advanced Scalable Texture Profile" },
     { FF_PROFILE_MPEG4_SIMPLE_STUDIO,             "Simple Studio Profile" },
     { FF_PROFILE_MPEG4_ADVANCED_SIMPLE,           "Advanced Simple Profile" },
     { FF_PROFILE_UNKNOWN },
 };
 
 static const AVOption mpeg4_options[] = {
     {"quarter_sample", "1/4 subpel MC", offsetof(MpegEncContext, quarter_sample), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
     {"divx_packed", "divx style packed b frames", offsetof(MpegEncContext, divx_packed), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
     {NULL}
 };
 
 static const AVClass mpeg4_class = {
     "MPEG4 Video Decoder",
     av_default_item_name,
     mpeg4_options,
     LIBAVUTIL_VERSION_INT,
 };
 
+const enum AVPixelFormat ff_mpeg4_hwaccel_pixfmt_list_420[] = {
+#if CONFIG_VAAPI
+   AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_VDPAU
+//   AV_PIX_FMT_VDPAU_MPEG4,
+   AV_PIX_FMT_VDPAU,
+#endif
+   AV_PIX_FMT_YUV420P,
+   AV_PIX_FMT_NONE
+};
+
 AVCodec ff_mpeg4_decoder = {
     .name                  = "mpeg4",
     .long_name             = NULL_IF_CONFIG_SMALL("MPEG-4 part 2"),
     .type                  = AVMEDIA_TYPE_VIDEO,
     .id                    = AV_CODEC_ID_MPEG4,
     .priv_data_size        = sizeof(Mpeg4DecContext),
     .init                  = decode_init,
     .close                 = ff_h263_decode_end,
     .decode                = ff_h263_decode_frame,
-    .capabilities          = CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1 |
+    .capabilities          = /*CODEC_CAP_DRAW_HORIZ_BAND | */CODEC_CAP_DR1 |
                              CODEC_CAP_TRUNCATED | CODEC_CAP_DELAY |
                              CODEC_CAP_FRAME_THREADS,
     .flush                 = ff_mpeg_flush,
     .max_lowres            = 3,
-    .pix_fmts              = ff_h263_hwaccel_pixfmt_list_420,
+    .pix_fmts              = ff_mpeg4_hwaccel_pixfmt_list_420,
     .profiles              = NULL_IF_CONFIG_SMALL(mpeg4_video_profiles),
     .update_thread_context = ONLY_IF_THREADS_ENABLED(mpeg4_update_thread_context),
     .priv_class = &mpeg4_class,
 };
 
 
 #if CONFIG_MPEG4_VDPAU_DECODER
 static const AVClass mpeg4_vdpau_class = {
     "MPEG4 Video VDPAU Decoder",
     av_default_item_name,
     mpeg4_options,
     LIBAVUTIL_VERSION_INT,
 };
 
 AVCodec ff_mpeg4_vdpau_decoder = {
     .name           = "mpeg4_vdpau",
     .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 (VDPAU)"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MPEG4,
     .priv_data_size = sizeof(Mpeg4DecContext),
     .init           = decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
+    .flush          = ff_mpeg_flush,
     .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_DELAY |
                       CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU_MPEG4,
+    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU,
                                                   AV_PIX_FMT_NONE },
+    .profiles       = NULL_IF_CONFIG_SMALL(mpeg4_video_profiles),
     .priv_class     = &mpeg4_vdpau_class,
 };
 #endif
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/msmpeg4dec.c ffmpeg-2.4.6-Helix/libavcodec/msmpeg4dec.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/msmpeg4dec.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/msmpeg4dec.c	2015-11-27 23:23:42.794882089 +0100
@@ -884,97 +884,159 @@
     code = get_vlc2(&s->gb, mv->vlc.table, MV_VLC_BITS, 2);
     if (code < 0){
         av_log(s->avctx, AV_LOG_ERROR, "illegal MV code at %d %d\n", s->mb_x, s->mb_y);
         return -1;
     }
     if (code == mv->n) {
         mx = get_bits(&s->gb, 6);
         my = get_bits(&s->gb, 6);
     } else {
         mx = mv->table_mvx[code];
         my = mv->table_mvy[code];
     }
 
     mx += *mx_ptr - 32;
     my += *my_ptr - 32;
     /* WARNING : they do not do exactly modulo encoding */
     if (mx <= -64)
         mx += 64;
     else if (mx >= 64)
         mx -= 64;
 
     if (my <= -64)
         my += 64;
     else if (my >= 64)
         my -= 64;
     *mx_ptr = mx;
     *my_ptr = my;
     return 0;
 }
 
+const enum AVPixelFormat ff_msmpeg_hwaccel_pixfmt_list_420[] = {
+#if CONFIG_VAAPI
+    AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_VDPAU
+//    AV_PIX_FMT_VDPAU_MSMPEG4V3,
+    AV_PIX_FMT_VDPAU,
+#endif
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NONE
+};
+
 AVCodec ff_msmpeg4v1_decoder = {
     .name           = "msmpeg4v1",
     .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MSMPEG4V1,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
     .capabilities   = CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_msmpeg4v2_decoder = {
     .name           = "msmpeg4v2",
     .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MSMPEG4V2,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
     .capabilities   = CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_msmpeg4v3_decoder = {
     .name           = "msmpeg4",
     .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MSMPEG4V3,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
     .capabilities   = CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_wmv1_decoder = {
     .name           = "wmv1",
     .long_name      = NULL_IF_CONFIG_SMALL("Windows Media Video 7"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_WMV1,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
     .capabilities   = CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
+};
+
+#define CONFIG_MSMPEGV3_VDPAU_DECODER 1
+#if CONFIG_MSMPEGV3_VDPAU_DECODER
+static const AVOption msmpeg_options[] = {
+    {"quarter_sample", "1/4 subpel MC", offsetof(MpegEncContext, quarter_sample), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
+    {"divx_packed", "divx style packed b frames", offsetof(MpegEncContext, divx_packed), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
+    {NULL}
+};
+
+static const AVClass msmpegv1_vdpau_class = {
+    "MSMPEG4 Video VDPAU Decoder",
+    av_default_item_name,
+    msmpeg_options,
+    LIBAVUTIL_VERSION_INT,
 };
+ 
+AVCodec ff_msmpeg4v3_vdpau_decoder = {
+    .name           = "msmpeg4_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V3,
+    .priv_data_size = sizeof(MpegEncContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_HWACCEL_VDPAU,
+    .max_lowres     = 3,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
+};
+
+AVCodec ff_msmpeg4v2_vdpau_decoder = {
+    .name           = "msmpeg4v2_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V2,
+    .priv_data_size = sizeof(MpegEncContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_HWACCEL_VDPAU,
+    .max_lowres     = 3,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_MSMPEG4V2, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
+};
+
+AVCodec ff_msmpeg4v1_vdpau_decoder = {
+    .name           = "msmpeg4v1_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V1,
+    .priv_data_size = sizeof(MpegEncContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_HWACCEL_VDPAU,
+    .max_lowres     = 3,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_MSMPEG4V1, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
+};
+
+#endif
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/old_codec_ids.h ffmpeg-2.4.6-Helix/libavcodec/old_codec_ids.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/old_codec_ids.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/old_codec_ids.h	2015-04-12 13:47:40.716643996 +0200
@@ -22,60 +22,61 @@
 /*
  * This header exists to prevent new codec IDs from being accidentally added to
  * the deprecated list.
  * Do not include it directly. It will be removed on next major bump
  *
  * Do not add new items to this list. Use the AVCodecID enum instead.
  */
 
     CODEC_ID_NONE = AV_CODEC_ID_NONE,
 
     /* video codecs */
     CODEC_ID_MPEG1VIDEO,
     CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
 #if FF_API_XVMC
     CODEC_ID_MPEG2VIDEO_XVMC,
 #endif
     CODEC_ID_H261,
     CODEC_ID_H263,
     CODEC_ID_RV10,
     CODEC_ID_RV20,
     CODEC_ID_MJPEG,
     CODEC_ID_MJPEGB,
     CODEC_ID_LJPEG,
     CODEC_ID_SP5X,
     CODEC_ID_JPEGLS,
     CODEC_ID_MPEG4,
     CODEC_ID_RAWVIDEO,
     CODEC_ID_MSMPEG4V1,
     CODEC_ID_MSMPEG4V2,
     CODEC_ID_MSMPEG4V3,
+    CODEC_ID_MSMPEG4V4,
     CODEC_ID_WMV1,
     CODEC_ID_WMV2,
     CODEC_ID_H263P,
     CODEC_ID_H263I,
     CODEC_ID_FLV1,
     CODEC_ID_SVQ1,
     CODEC_ID_SVQ3,
     CODEC_ID_DVVIDEO,
     CODEC_ID_HUFFYUV,
     CODEC_ID_CYUV,
     CODEC_ID_H264,
     CODEC_ID_INDEO3,
     CODEC_ID_VP3,
     CODEC_ID_THEORA,
     CODEC_ID_ASV1,
     CODEC_ID_ASV2,
     CODEC_ID_FFV1,
     CODEC_ID_4XM,
     CODEC_ID_VCR1,
     CODEC_ID_CLJR,
     CODEC_ID_MDEC,
     CODEC_ID_ROQ,
     CODEC_ID_INTERPLAY_VIDEO,
     CODEC_ID_XAN_WC3,
     CODEC_ID_XAN_WC4,
     CODEC_ID_RPZA,
     CODEC_ID_CINEPAK,
     CODEC_ID_WS_VQA,
     CODEC_ID_MSRLE,
     CODEC_ID_MSVIDEO1,
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/utils.c ffmpeg-2.4.6-Helix/libavcodec/utils.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/utils.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/utils.c	2015-04-21 23:02:33.370142488 +0200
@@ -1119,62 +1119,62 @@
 {
     int i;
 
     for (i = 0; i < count; i++) {
         int r = func(c, arg, i, 0);
         if (ret)
             ret[i] = r;
     }
     return 0;
 }
 
 enum AVPixelFormat avpriv_find_pix_fmt(const PixelFormatTag *tags,
                                        unsigned int fourcc)
 {
     while (tags->pix_fmt >= 0) {
         if (tags->fourcc == fourcc)
             return tags->pix_fmt;
         tags++;
     }
     return AV_PIX_FMT_NONE;
 }
 
 static int is_hwaccel_pix_fmt(enum AVPixelFormat pix_fmt)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
     return desc->flags & AV_PIX_FMT_FLAG_HWACCEL;
 }
 
 enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
 {
-    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))
-        ++fmt;
+//    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))
+//         ++fmt;
     return fmt[0];
 }
 
 static AVHWAccel *find_hwaccel(enum AVCodecID codec_id,
                                enum AVPixelFormat pix_fmt)
 {
     AVHWAccel *hwaccel = NULL;
 
     while ((hwaccel = av_hwaccel_next(hwaccel)))
         if (hwaccel->id == codec_id
             && hwaccel->pix_fmt == pix_fmt)
             return hwaccel;
     return NULL;
 }
 
 
 int ff_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)
 {
     const AVPixFmtDescriptor *desc;
     enum AVPixelFormat ret = avctx->get_format(avctx, fmt);
 
     desc = av_pix_fmt_desc_get(ret);
     if (!desc)
         return AV_PIX_FMT_NONE;
 
     if (avctx->hwaccel && avctx->hwaccel->uninit)
         avctx->hwaccel->uninit(avctx);
     av_freep(&avctx->internal->hwaccel_priv_data);
     avctx->hwaccel = NULL;
 
@@ -2266,60 +2266,61 @@
     if (!avctx->codec)
         return AVERROR(EINVAL);
     if (avctx->codec->type != AVMEDIA_TYPE_VIDEO) {
         av_log(avctx, AV_LOG_ERROR, "Invalid media type for video\n");
         return AVERROR(EINVAL);
     }
 
     *got_picture_ptr = 0;
     if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
         return AVERROR(EINVAL);
 
     av_frame_unref(picture);
 
     if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
         int did_split = av_packet_split_side_data(&tmp);
         ret = apply_param_change(avctx, &tmp);
         if (ret < 0) {
             av_log(avctx, AV_LOG_ERROR, "Error applying parameter changes.\n");
             if (avctx->err_recognition & AV_EF_EXPLODE)
                 goto fail;
         }
 
         avctx->internal->pkt = &tmp;
         if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
             ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                          &tmp);
         else {
             ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                        &tmp);
             picture->pkt_dts = avpkt->dts;
+            //picture->pts = avpkt->pts;
 
             if(!avctx->has_b_frames){
                 av_frame_set_pkt_pos(picture, avpkt->pos);
             }
             //FIXME these should be under if(!avctx->has_b_frames)
             /* get_buffer is supposed to set frame parameters */
             if (!(avctx->codec->capabilities & CODEC_CAP_DR1)) {
                 if (!picture->sample_aspect_ratio.num)    picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
                 if (!picture->width)                      picture->width               = avctx->width;
                 if (!picture->height)                     picture->height              = avctx->height;
                 if (picture->format == AV_PIX_FMT_NONE)   picture->format              = avctx->pix_fmt;
             }
         }
         add_metadata_from_side_data(avctx, picture);
 
 fail:
         emms_c(); //needed to avoid an emms_c() call before every return;
 
         avctx->internal->pkt = NULL;
         if (did_split) {
             av_packet_free_side_data(&tmp);
             if(ret == tmp.size)
                 ret = avpkt->size;
         }
 
         if (*got_picture_ptr) {
             if (!avctx->refcounted_frames) {
                 int err = unrefcount_frame(avci, picture);
                 if (err < 0)
                     return err;
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vc1dec.c ffmpeg-2.4.6-Helix/libavcodec/vc1dec.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vc1dec.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vc1dec.c	2015-11-27 23:23:44.814816535 +0100
@@ -6291,77 +6291,77 @@
 };
 
 #if CONFIG_WMV3_DECODER
 AVCodec ff_wmv3_decoder = {
     .name           = "wmv3",
     .long_name      = NULL_IF_CONFIG_SMALL("Windows Media Video 9"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_WMV3,
     .priv_data_size = sizeof(VC1Context),
     .init           = vc1_decode_init,
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .flush          = ff_mpeg_flush,
     .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY,
     .pix_fmts       = vc1_hwaccel_pixfmt_list_420,
     .profiles       = NULL_IF_CONFIG_SMALL(profiles)
 };
 #endif
 
 #if CONFIG_WMV3_VDPAU_DECODER
 AVCodec ff_wmv3_vdpau_decoder = {
     .name           = "wmv3_vdpau",
     .long_name      = NULL_IF_CONFIG_SMALL("Windows Media Video 9 VDPAU"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_WMV3,
     .priv_data_size = sizeof(VC1Context),
     .init           = vc1_decode_init,
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_WMV3, AV_PIX_FMT_NONE },
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
     .profiles       = NULL_IF_CONFIG_SMALL(profiles)
 };
 #endif
 
 #if CONFIG_VC1_VDPAU_DECODER
 AVCodec ff_vc1_vdpau_decoder = {
     .name           = "vc1_vdpau",
     .long_name      = NULL_IF_CONFIG_SMALL("SMPTE VC-1 VDPAU"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_VC1,
     .priv_data_size = sizeof(VC1Context),
     .init           = vc1_decode_init,
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_VC1, AV_PIX_FMT_NONE },
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
     .profiles       = NULL_IF_CONFIG_SMALL(profiles)
 };
 #endif
 
 #if CONFIG_WMV3IMAGE_DECODER
 AVCodec ff_wmv3image_decoder = {
     .name           = "wmv3image",
     .long_name      = NULL_IF_CONFIG_SMALL("Windows Media Video 9 Image"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_WMV3IMAGE,
     .priv_data_size = sizeof(VC1Context),
     .init           = vc1_decode_init,
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .capabilities   = CODEC_CAP_DR1,
     .flush          = vc1_sprite_flush,
     .pix_fmts       = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
         AV_PIX_FMT_NONE
     },
 };
 #endif
 
 #if CONFIG_VC1IMAGE_DECODER
 AVCodec ff_vc1image_decoder = {
     .name           = "vc1image",
     .long_name      = NULL_IF_CONFIG_SMALL("Windows Media Video 9 Image v2"),
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_VC1IMAGE,
     .priv_data_size = sizeof(VC1Context),
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau.c ffmpeg-2.4.6-Helix/libavcodec/vdpau.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau.c	2015-04-12 14:59:02.433297203 +0200
@@ -409,63 +409,65 @@
 
     render = (struct vdpau_render_state *)s->current_picture_ptr->f->data[0];
     assert(render);
 
     /* fill VdpPictureInfoMPEG4Part2 struct */
     render->info.mpeg4.trd[0]                            = s->pp_time;
     render->info.mpeg4.trb[0]                            = s->pb_time;
     render->info.mpeg4.trd[1]                            = s->pp_field_time >> 1;
     render->info.mpeg4.trb[1]                            = s->pb_field_time >> 1;
     render->info.mpeg4.vop_time_increment_resolution     = s->avctx->time_base.den;
     render->info.mpeg4.vop_coding_type                   = 0;
     render->info.mpeg4.vop_fcode_forward                 = s->f_code;
     render->info.mpeg4.vop_fcode_backward                = s->b_code;
     render->info.mpeg4.resync_marker_disable             = !ctx->resync_marker;
     render->info.mpeg4.interlaced                        = !s->progressive_sequence;
     render->info.mpeg4.quant_type                        = s->mpeg_quant;
     render->info.mpeg4.quarter_sample                    = s->quarter_sample;
     render->info.mpeg4.short_video_header                = s->avctx->codec->id == AV_CODEC_ID_H263;
     render->info.mpeg4.rounding_control                  = s->no_rounding;
     render->info.mpeg4.alternate_vertical_scan_flag      = s->alternate_scan;
     render->info.mpeg4.top_field_first                   = s->top_field_first;
     for (i = 0; i < 64; ++i) {
         render->info.mpeg4.intra_quantizer_matrix[i]     = s->intra_matrix[i];
         render->info.mpeg4.non_intra_quantizer_matrix[i] = s->inter_matrix[i];
     }
     render->info.mpeg4.forward_reference                 = VDP_INVALID_HANDLE;
     render->info.mpeg4.backward_reference                = VDP_INVALID_HANDLE;
 
     switch (s->pict_type) {
     case AV_PICTURE_TYPE_B:
+    case AV_PICTURE_TYPE_S:
         next = (struct vdpau_render_state *)s->next_picture.f->data[0];
         assert(next);
         render->info.mpeg4.backward_reference     = next->surface;
+        if( s->pict_type != AV_PICTURE_TYPE_S)
         render->info.mpeg4.vop_coding_type        = 2;
         // no break here, going to set forward prediction
     case AV_PICTURE_TYPE_P:
         last = (struct vdpau_render_state *)s->last_picture.f->data[0];
         assert(last);
         render->info.mpeg4.forward_reference      = last->surface;
     }
 
     ff_vdpau_add_data_chunk(s->current_picture_ptr->f->data[0], buf, buf_size);
 
     ff_mpeg_draw_horiz_band(s, 0, s->avctx->height);
     render->bitstream_buffers_used = 0;
 }
 #endif /* CONFIG_MPEG4_VDPAU_DECODER */
 
 int av_vdpau_get_profile(AVCodecContext *avctx, VdpDecoderProfile *profile)
 {
 #define PROFILE(prof)       \
 do {                        \
     *profile = prof;        \
     return 0;               \
 } while (0)
 
     switch (avctx->codec_id) {
     case AV_CODEC_ID_MPEG1VIDEO:               PROFILE(VDP_DECODER_PROFILE_MPEG1);
     case AV_CODEC_ID_MPEG2VIDEO:
         switch (avctx->profile) {
         case FF_PROFILE_MPEG2_MAIN:            PROFILE(VDP_DECODER_PROFILE_MPEG2_MAIN);
         case FF_PROFILE_MPEG2_SIMPLE:          PROFILE(VDP_DECODER_PROFILE_MPEG2_SIMPLE);
         default:                               return AVERROR(EINVAL);
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau.h ffmpeg-2.4.6-Helix/libavcodec/vdpau.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau.h	2015-04-12 13:47:40.716643996 +0200
@@ -74,60 +74,61 @@
                                const VdpBitstreamBuffer *);
 
 /**
  * This structure is used to share data between the libavcodec library and
  * the client video application.
  * The user shall allocate the structure via the av_alloc_vdpau_hwaccel
  * function and make it available as
  * AVCodecContext.hwaccel_context. Members can be set by the user once
  * during initialization or through each AVCodecContext.get_buffer()
  * function call. In any case, they must be valid prior to calling
  * decoding functions.
  *
  * The size of this structure is not a part of the public ABI and must not
  * be used outside of libavcodec. Use av_vdpau_alloc_context() to allocate an
  * AVVDPAUContext.
  */
 typedef struct AVVDPAUContext {
     /**
      * VDPAU decoder handle
      *
      * Set by user.
      */
     VdpDecoder decoder;
 
     /**
      * VDPAU decoder render callback
      *
      * Set by the user.
      */
     VdpDecoderRender *render;
+    VdpDecoderSetControlData *set_video_header;
 
 #if FF_API_BUFS_VDPAU
     /**
      * VDPAU picture information
      *
      * Set by libavcodec.
      */
     attribute_deprecated
     union AVVDPAUPictureInfo info;
 
     /**
      * Allocated size of the bitstream_buffers table.
      *
      * Set by libavcodec.
      */
     attribute_deprecated
     int bitstream_buffers_allocated;
 
     /**
      * Useful bitstream buffers in the bitstream buffers table.
      *
      * Set by libavcodec.
      */
     attribute_deprecated
     int bitstream_buffers_used;
 
    /**
      * Table of bitstream buffers.
      * The user is responsible for freeing this buffer using av_freep().
      *
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_internal.h ffmpeg-2.4.6-Helix/libavcodec/vdpau_internal.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_internal.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau_internal.h	2015-04-12 13:50:08.312124932 +0200
@@ -54,51 +54,53 @@
 #else
 #include "vdpau.h"
 #endif
 
 struct vdpau_picture_context {
     /**
      * VDPAU picture information.
      */
     union AVVDPAUPictureInfo info;
 
     /**
      * Allocated size of the bitstream_buffers table.
      */
     int bitstream_buffers_allocated;
 
     /**
      * Useful bitstream buffers in the bitstream buffers table.
      */
     int bitstream_buffers_used;
 
    /**
      * Table of bitstream buffers.
      */
     VdpBitstreamBuffer *bitstream_buffers;
 };
 #endif
 
 int ff_vdpau_common_start_frame(struct vdpau_picture_context *pic,
                                 const uint8_t *buffer, uint32_t size);
 int ff_vdpau_mpeg_end_frame(AVCodecContext *avctx);
+int ff_vdpau_msmpeg_end_frame(AVCodecContext *avctx);
+
 int ff_vdpau_add_buffer(struct vdpau_picture_context *pic, const uint8_t *buf,
                         uint32_t buf_size);
 
 
 void ff_vdpau_add_data_chunk(uint8_t *data, const uint8_t *buf,
                              int buf_size);
 
 void ff_vdpau_mpeg_picture_complete(MpegEncContext *s, const uint8_t *buf,
                                     int buf_size, int slice_count);
 
 void ff_vdpau_h264_picture_start(H264Context *h);
 void ff_vdpau_h264_set_reference_frames(H264Context *h);
 void ff_vdpau_h264_picture_complete(H264Context *h);
 
 void ff_vdpau_vc1_decode_picture(MpegEncContext *s, const uint8_t *buf,
                                  int buf_size);
 
 void ff_vdpau_mpeg4_decode_picture(Mpeg4DecContext *s, const uint8_t *buf,
                                    int buf_size);
 
 #endif /* AVCODEC_VDPAU_INTERNAL_H */
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg12.c ffmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg12.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg12.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg12.c	2015-11-25 21:45:59.256896233 +0100
@@ -72,50 +72,50 @@
     info->f_code[1][1]               = s->mpeg_f_code[1][1];
     for (i = 0; i < 64; ++i) {
         info->intra_quantizer_matrix[i]     = s->intra_matrix[i];
         info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];
     }
 
     return ff_vdpau_common_start_frame(pic_ctx, buffer, size);
 }
 
 static int vdpau_mpeg_decode_slice(AVCodecContext *avctx,
                                    const uint8_t *buffer, uint32_t size)
 {
     MpegEncContext * const s = avctx->priv_data;
     Picture *pic             = s->current_picture_ptr;
     struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;
     int val;
 
     val = ff_vdpau_add_buffer(pic_ctx, buffer, size);
     if (val < 0)
         return val;
 
     pic_ctx->info.mpeg.slice_count++;
     return 0;
 }
 
 #if CONFIG_MPEG1_VDPAU_HWACCEL
 AVHWAccel ff_mpeg1_vdpau_hwaccel = {
     .name           = "mpeg1_vdpau",
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MPEG1VIDEO,
-    .pix_fmt        = AV_PIX_FMT_VDPAU,
+    .pix_fmt        = AV_PIX_FMT_VDPAU_MPEG1,
     .start_frame    = vdpau_mpeg_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg_decode_slice,
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
 };
 #endif
 
 #if CONFIG_MPEG2_VDPAU_HWACCEL
 AVHWAccel ff_mpeg2_vdpau_hwaccel = {
     .name           = "mpeg2_vdpau",
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MPEG2VIDEO,
-    .pix_fmt        = AV_PIX_FMT_VDPAU,
+    .pix_fmt        = AV_PIX_FMT_VDPAU_MPEG2,
     .start_frame    = vdpau_mpeg_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg_decode_slice,
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
 };
 #endif
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg4.c ffmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg4.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg4.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau_mpeg4.c	2015-11-27 23:15:08.031555353 +0100
@@ -1,115 +1,180 @@
 /*
  * MPEG-4 Part 2 / H.263 decode acceleration through VDPAU
  *
  * Copyright (c) 2008 NVIDIA
  * Copyright (c) 2013 Rémi Denis-Courmont
  *
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #include <vdpau/vdpau.h>
 
 #include "avcodec.h"
 #include "mpeg4video.h"
 #include "vdpau.h"
 #include "vdpau_internal.h"
 
+int vdpau_mpeg4_create_video_headers(AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data);
+
 static int vdpau_mpeg4_start_frame(AVCodecContext *avctx,
                                    const uint8_t *buffer, uint32_t size)
 {
     Mpeg4DecContext *ctx = avctx->priv_data;
     MpegEncContext * const s = &ctx->m;
     Picture *pic             = s->current_picture_ptr;
     struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;
     VdpPictureInfoMPEG4Part2 *info = &pic_ctx->info.mpeg4;
     VdpVideoSurface ref;
     int i;
 
     /* fill VdpPictureInfoMPEG4Part2 struct */
     info->forward_reference  = VDP_INVALID_HANDLE;
     info->backward_reference = VDP_INVALID_HANDLE;
     info->vop_coding_type    = 0;
 
     switch (s->pict_type) {
     case AV_PICTURE_TYPE_B:
+    case AV_PICTURE_TYPE_S:
         ref = ff_vdpau_get_surface_id(s->next_picture.f);
         assert(ref != VDP_INVALID_HANDLE);
         info->backward_reference = ref;
+        if( s->pict_type != AV_PICTURE_TYPE_S)
         info->vop_coding_type    = 2;
         /* fall-through */
     case AV_PICTURE_TYPE_P:
         ref = ff_vdpau_get_surface_id(s->last_picture.f);
         assert(ref != VDP_INVALID_HANDLE);
         info->forward_reference  = ref;
     }
 
     info->trd[0]                            = s->pp_time;
     info->trb[0]                            = s->pb_time;
     info->trd[1]                            = s->pp_field_time >> 1;
     info->trb[1]                            = s->pb_field_time >> 1;
     info->vop_time_increment_resolution     = s->avctx->time_base.den;
     info->vop_fcode_forward                 = s->f_code;
     info->vop_fcode_backward                = s->b_code;
     info->resync_marker_disable             = !ctx->resync_marker;
     info->interlaced                        = !s->progressive_sequence;
     info->quant_type                        = s->mpeg_quant;
     info->quarter_sample                    = s->quarter_sample;
     info->short_video_header                = avctx->codec->id == AV_CODEC_ID_H263;
     info->rounding_control                  = s->no_rounding;
     info->alternate_vertical_scan_flag      = s->alternate_scan;
     info->top_field_first                   = s->top_field_first;
     for (i = 0; i < 64; ++i) {
         info->intra_quantizer_matrix[i]     = s->intra_matrix[i];
         info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];
     }
 
     ff_vdpau_common_start_frame(pic_ctx, buffer, size);
     return ff_vdpau_add_buffer(pic_ctx, buffer, size);
 }
 
 static int vdpau_mpeg4_decode_slice(av_unused AVCodecContext *avctx,
                                     av_unused const uint8_t *buffer,
                                     av_unused uint32_t size)
 {
      return 0;
 }
 
+int vdpau_mpeg4_create_video_headers(AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data)
+{
+   Mpeg4DecContext * const s = avctx->priv_data;
+   memset(data, 0x0, sizeof(*data));
+    
+   if(id == VDP_MPEG4_VOL_HEADER) 
+   {
+      VdpDecoderMpeg4VolHeader *vol = &(data->mpeg4VolHdr);
+        
+      vol->struct_version               = VDP_MPEG4_STRUCT_VERSION;
+      vol->video_object_type_indication = s->m.vo_type;
+      vol->aspect_ratio_info            = s->m.aspect_ratio_info;
+      vol->par_width                    = s->m.avctx->sample_aspect_ratio.num;
+      vol->par_height                   = s->m.avctx->sample_aspect_ratio.den;
+      vol->vol_control_parameters       = s->vol_control_parameters;
+      vol->low_delay                    = s->m.low_delay;
+      vol->video_object_layer_shape     = s->shape;
+      vol->vop_time_increment_resolution = s->m.avctx->time_base.den;
+      vol->video_object_layer_width     = s->m.width;
+      vol->video_object_layer_height    = s->m.height;
+      vol->interlaced                   = s->m.progressive_frame ^ 1;
+      vol->sprite_enable                = s->vol_sprite_usage;
+      vol->no_of_sprite_warping_points  = s->num_sprite_warping_points;
+      vol->sprite_warping_accuracy      = s->m.sprite_warping_accuracy;
+      vol->sprite_brightness_change     = s->sprite_brightness_change;
+      vol->quant_precision              = s->m.quant_precision;
+      vol->quant_type                   = s->m.mpeg_quant;
+      for(int i=0; i < 64; ++i)
+      {
+            //to be done matrices
+      }
+      vol->quarter_sample               = s->m.quarter_sample;
+      vol->resync_marker_disable        = s->resync_marker;
+      vol->data_partitioned             = s->m.data_partitioning;
+      vol->reversible_vlc               = s->rvlc;
+      vol->newpred_enable               = s->new_pred;
+      vol->scalability                  = s->scalability;
+      vol->enhancement_type             = s->enhancement_type;
+
+      return 1;
+   }
+   return 0;
+}
+
+static int vdpau_mpeg4_set_video_header (AVCodecContext *avctx, uint32_t id)
+{
+    AVVDPAUContext *hwctx = avctx->hwaccel_context;
+    VdpDecoderControlData data;
+
+    if(!hwctx->set_video_header)
+       return 0;
+
+    if(vdpau_mpeg4_create_video_headers(avctx, id, &data))
+       return hwctx->set_video_header(hwctx->decoder, id, &data);
+
+    return 0;
+}
+
+
 #if CONFIG_H263_VDPAU_HWACCEL
 AVHWAccel ff_h263_vdpau_hwaccel = {
     .name           = "h263_vdpau",
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_H263,
     .pix_fmt        = AV_PIX_FMT_VDPAU,
     .start_frame    = vdpau_mpeg4_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_mpeg4_set_video_header
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
 };
 #endif
 
 #if CONFIG_MPEG4_VDPAU_HWACCEL
 AVHWAccel ff_mpeg4_vdpau_hwaccel = {
     .name           = "mpeg4_vdpau",
     .type           = AVMEDIA_TYPE_VIDEO,
     .id             = AV_CODEC_ID_MPEG4,
     .pix_fmt        = AV_PIX_FMT_VDPAU,
     .start_frame    = vdpau_mpeg4_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_mpeg4_set_video_header
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
 };
 #endif
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_msmpeg4.c ffmpeg-2.4.6-Helix/libavcodec/vdpau_msmpeg4.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavcodec/vdpau_msmpeg4.c	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavcodec/vdpau_msmpeg4.c	2015-11-27 23:23:41.804914216 +0100
@@ -0,0 +1,145 @@
+/*
+ * MPEG-4 Part 2 / H.263 decode acceleration through VDPAU
+ *
+ * Copyright (c) 2008 NVIDIA
+ * Copyright (c) 2013 Rémi Denis-Courmont
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <vdpau/vdpau.h>
+
+#include "avcodec.h"
+#include "vdpau.h"
+#include "vdpau_internal.h"
+
+static int vdpau_msmpeg4_start_frame(AVCodecContext *avctx,
+                                   const uint8_t *buffer, uint32_t size)
+{
+   Mpeg4DecContext *ctx = avctx->priv_data;
+   MpegEncContext * const s = &ctx->m;
+   Picture *pic             = s->current_picture_ptr;
+   struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;
+   VdpPictureInfoMPEG4Part2 *info = &pic_ctx->info.mpeg4;
+   VdpVideoSurface ref;
+   int i;
+
+   /* fill VdpPictureInfoMPEG4Part2 struct */
+   info->forward_reference  = VDP_INVALID_HANDLE;
+   info->backward_reference = VDP_INVALID_HANDLE;
+   info->vop_coding_type    = 0;
+
+   switch (s->pict_type) {
+      case AV_PICTURE_TYPE_B:
+      case AV_PICTURE_TYPE_S:
+         ref = ff_vdpau_get_surface_id(s->next_picture.f);
+         assert(ref != VDP_INVALID_HANDLE);
+         info->backward_reference = ref;
+         if( s->pict_type != AV_PICTURE_TYPE_S)
+            info->vop_coding_type    = 2;
+         /* fall-through */
+      case AV_PICTURE_TYPE_P:
+         ref = ff_vdpau_get_surface_id(s->last_picture.f);
+         assert(ref != VDP_INVALID_HANDLE);
+         info->forward_reference  = ref;
+   }
+
+   info->trd[0]                            = s->pp_time;
+   info->trb[0]                            = s->pb_time;
+   info->trd[1]                            = s->pp_field_time >> 1;
+   info->trb[1]                            = s->pb_field_time >> 1;
+   info->vop_time_increment_resolution     = s->avctx->time_base.den;
+   info->vop_fcode_forward                 = s->f_code;
+   info->vop_fcode_backward                = s->b_code;
+   info->resync_marker_disable             = !ctx->resync_marker;
+   info->interlaced                        = !s->progressive_sequence;
+   info->quant_type                        = s->mpeg_quant;
+   info->quarter_sample                    = s->quarter_sample;
+   info->short_video_header                = avctx->codec->id == AV_CODEC_ID_H263;
+   info->rounding_control                  = s->no_rounding;
+   info->alternate_vertical_scan_flag      = s->alternate_scan;
+   info->top_field_first                   = s->top_field_first;
+   for (i = 0; i < 64; ++i) {
+      info->intra_quantizer_matrix[i]     = s->intra_matrix[i];
+      info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];
+   }
+
+   ff_vdpau_common_start_frame(pic_ctx, buffer, size);
+   return ff_vdpau_add_buffer(pic_ctx, buffer, size);
+}
+
+static int vdpau_mpeg4_decode_slice(av_unused AVCodecContext *avctx,
+                                    av_unused const uint8_t *buffer,
+                                    av_unused uint32_t size)
+{
+     return 0;
+}
+static int vdpau_msmpeg4_set_video_header (AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data)
+{
+   Mpeg4DecContext * const s = avctx->priv_data;
+   memset(data, 0x0, sizeof(*data));
+    
+   if(id == VDP_MPEG4_VOL_HEADER) 
+   {
+      VdpDecoderMpeg4VolHeader *vol = &(data->mpeg4VolHdr);
+        
+      vol->struct_version               = VDP_MPEG4_STRUCT_VERSION;
+      vol->video_object_type_indication = s->m.vo_type;
+      vol->aspect_ratio_info            = s->m.aspect_ratio_info;
+      vol->par_width                    = s->m.avctx->sample_aspect_ratio.num;
+      vol->par_height                   = s->m.avctx->sample_aspect_ratio.den;
+      vol->vol_control_parameters       = s->vol_control_parameters;
+      vol->low_delay                    = s->m.low_delay;
+      vol->video_object_layer_shape     = s->shape;
+      vol->vop_time_increment_resolution = s->m.avctx->time_base.den;
+      vol->video_object_layer_width     = s->m.width;
+      vol->video_object_layer_height    = s->m.height;
+      vol->interlaced                   = s->m.progressive_frame ^ 1;
+      vol->sprite_enable                = s->vol_sprite_usage;
+      vol->no_of_sprite_warping_points  = s->num_sprite_warping_points;
+      vol->sprite_warping_accuracy      = s->m.sprite_warping_accuracy;
+      vol->sprite_brightness_change     = s->sprite_brightness_change;
+      vol->quant_precision              = s->m.quant_precision;
+      vol->quant_type                   = s->m.mpeg_quant;
+      for(int i=0; i < 64; ++i)
+      {
+            //to be done matrices
+      }
+      vol->quarter_sample               = s->m.quarter_sample;
+      vol->resync_marker_disable        = s->resync_marker;
+      vol->data_partitioned             = s->m.data_partitioning;
+      vol->reversible_vlc               = s->rvlc;
+      vol->newpred_enable               = s->new_pred;
+      vol->scalability                  = s->scalability;
+      vol->enhancement_type             = s->enhancement_type;
+
+      return 1;
+    }
+    return 0;
+}
+
+AVHWAccel ff_msmpeg4v3_vdpau_hwaccel = {
+    .name           = "msmpeg4v3_vdpau",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V3,
+    .pix_fmt        = AV_PIX_FMT_VDPAU,
+    .start_frame    = vdpau_msmpeg4_start_frame,
+    .end_frame      = ff_vdpau_mpeg_end_frame,
+    .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_msmpeg4_set_video_header,
+};
+
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.c ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.c	2015-04-12 13:47:40.726643690 +0200
@@ -113,60 +113,64 @@
     case IMGFMT_IYU1: return "Packed IYU1";
     case IMGFMT_IYU2: return "Packed IYU2";
     case IMGFMT_UYVY: return "Packed UYVY";
     case IMGFMT_UYNV: return "Packed UYNV";
     case IMGFMT_cyuv: return "Packed CYUV";
     case IMGFMT_Y422: return "Packed Y422";
     case IMGFMT_YUY2: return "Packed YUY2";
     case IMGFMT_YUNV: return "Packed YUNV";
     case IMGFMT_YVYU: return "Packed YVYU";
     case IMGFMT_Y41P: return "Packed Y41P";
     case IMGFMT_Y211: return "Packed Y211";
     case IMGFMT_Y41T: return "Packed Y41T";
     case IMGFMT_Y42T: return "Packed Y42T";
     case IMGFMT_V422: return "Packed V422";
     case IMGFMT_V655: return "Packed V655";
     case IMGFMT_CLJR: return "Packed CLJR";
     case IMGFMT_YUVP: return "Packed YUVP";
     case IMGFMT_UYVP: return "Packed UYVP";
     case IMGFMT_MPEGPES:         return "Mpeg PES";
     case IMGFMT_ZRMJPEGNI:       return "Zoran MJPEG non-interlaced";
     case IMGFMT_ZRMJPEGIT:       return "Zoran MJPEG top field first";
     case IMGFMT_ZRMJPEGIB:       return "Zoran MJPEG bottom field first";
     case IMGFMT_XVMC_MOCO_MPEG2: return "MPEG1/2 Motion Compensation";
     case IMGFMT_XVMC_IDCT_MPEG2: return "MPEG1/2 Motion Compensation and IDCT";
     case IMGFMT_VDPAU_MPEG1:     return "MPEG1 VDPAU acceleration";
     case IMGFMT_VDPAU_MPEG2:     return "MPEG2 VDPAU acceleration";
     case IMGFMT_VDPAU_H264:      return "H.264 VDPAU acceleration";
     case IMGFMT_VDPAU_MPEG4:     return "MPEG-4 Part 2 VDPAU acceleration";
     case IMGFMT_VDPAU_WMV3:      return "WMV3 VDPAU acceleration";
     case IMGFMT_VDPAU_VC1:       return "VC1 VDPAU acceleration";
+    case IMGFMT_VDPAU_MSMPEG4V1: return "MS MPEG-4 V1 VDPAU acceleration";
+    case IMGFMT_VDPAU_MSMPEG4V2: return "MS MPEG-4 V2 VDPAU acceleration";
+    case IMGFMT_VDPAU_MSMPEG4V3: return "MS MPEG-4 V3 VDPAU acceleration";
+    case IMGFMT_VDPAU_MSMPEG4V4: return "MS MPEG-4 V4 VDPAU acceleration";
     }
     snprintf(unknown_format,20,"Unknown 0x%04x",format);
     return unknown_format;
 }
 
 int ff_mp_get_chroma_shift(int format, int *x_shift, int *y_shift, int *component_bits)
 {
     int xs = 0, ys = 0;
     int bpp;
     int err = 0;
     int bits = 8;
     if ((format & 0xff0000f0) == 0x34000050)
         format = av_bswap32(format);
     if ((format & 0xf00000ff) == 0x50000034) {
         switch (format >> 24) {
         case 0x50:
             break;
         case 0x51:
             bits = 16;
             break;
         case 0x52:
             bits = 10;
             break;
         case 0x53:
             bits = 9;
             break;
         default:
             err = 1;
             break;
         }
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.h ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/img_format.h	2015-04-12 13:47:40.736643384 +0200
@@ -259,51 +259,55 @@
 #define IMGFMT_YUVP 0x50565559 // 10-bit YUYV
 #define IMGFMT_UYVP 0x50565955 // 10-bit UYVY
 
 /* Compressed Formats */
 #define IMGFMT_MPEGPES (('M'<<24)|('P'<<16)|('E'<<8)|('S'))
 #define IMGFMT_MJPEG (('M')|('J'<<8)|('P'<<16)|('G'<<24))
 /* Formats that are understood by zoran chips, we include
  * non-interlaced, interlaced top-first, interlaced bottom-first */
 #define IMGFMT_ZRMJPEGNI  (('Z'<<24)|('R'<<16)|('N'<<8)|('I'))
 #define IMGFMT_ZRMJPEGIT (('Z'<<24)|('R'<<16)|('I'<<8)|('T'))
 #define IMGFMT_ZRMJPEGIB (('Z'<<24)|('R'<<16)|('I'<<8)|('B'))
 
 // I think that this code could not be used by any other codec/format
 #define IMGFMT_XVMC 0x1DC70000
 #define IMGFMT_XVMC_MASK 0xFFFF0000
 #define IMGFMT_IS_XVMC(fmt) (((fmt)&IMGFMT_XVMC_MASK)==IMGFMT_XVMC)
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
 
 // VDPAU specific format.
 #define IMGFMT_VDPAU               0x1DC80000
 #define IMGFMT_VDPAU_MASK          0xFFFF0000
 #define IMGFMT_IS_VDPAU(fmt)       (((fmt)&IMGFMT_VDPAU_MASK)==IMGFMT_VDPAU)
 #define IMGFMT_VDPAU_MPEG1         (IMGFMT_VDPAU|0x01)
 #define IMGFMT_VDPAU_MPEG2         (IMGFMT_VDPAU|0x02)
 #define IMGFMT_VDPAU_H264          (IMGFMT_VDPAU|0x03)
 #define IMGFMT_VDPAU_WMV3          (IMGFMT_VDPAU|0x04)
 #define IMGFMT_VDPAU_VC1           (IMGFMT_VDPAU|0x05)
 #define IMGFMT_VDPAU_MPEG4         (IMGFMT_VDPAU|0x06)
+#define IMGFMT_VDPAU_MSMPEG4V1     (IMGFMT_VDPAU|0x07)
+#define IMGFMT_VDPAU_MSMPEG4V2     (IMGFMT_VDPAU|0x08)
+#define IMGFMT_VDPAU_MSMPEG4V3     (IMGFMT_VDPAU|0x09)
+#define IMGFMT_VDPAU_MSMPEG4V4     (IMGFMT_VDPAU|0x0A)
 
 #define IMGFMT_IS_HWACCEL(fmt) (IMGFMT_IS_VDPAU(fmt) || IMGFMT_IS_XVMC(fmt))
 
 typedef struct {
     void* data;
     int size;
     int id;        // stream id. usually 0x1E0
     int timestamp; // pts, 90000 Hz counter based
 } vo_mpegpes_t;
 
 const char *ff_vo_format_name(int format);
 
 /**
  * Calculates the scale shifts for the chroma planes for planar YUV
  *
  * \param component_bits bits per component
  * \return bits-per-pixel for format if successful (i.e. format is 3 or 4-planes planar YUV), 0 otherwise
  */
 int ff_mp_get_chroma_shift(int format, int *x_shift, int *y_shift, int *component_bits);
 
 #endif /* MPLAYER_IMG_FORMAT_H */
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/libvo/video_out.h ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/libvo/video_out.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/libmpcodecs/libvo/video_out.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavfilter/libmpcodecs/libvo/video_out.h	2015-04-12 13:47:40.736643384 +0200
@@ -74,60 +74,68 @@
 #define VOCTRL_DUPLICATE_FRAME 20
 // ... 21
 #define VOCTRL_START_SLICE 21
 
 #define VOCTRL_ONTOP 25
 #define VOCTRL_ROOTWIN 26
 #define VOCTRL_BORDER 27
 #define VOCTRL_DRAW_EOSD 28
 #define VOCTRL_GET_EOSD_RES 29
 
 #define VOCTRL_SET_DEINTERLACE 30
 #define VOCTRL_GET_DEINTERLACE 31
 
 #define VOCTRL_UPDATE_SCREENINFO 32
 
 // Vo can be used by xover
 #define VOCTRL_XOVERLAY_SUPPORT 22
 
 #define VOCTRL_XOVERLAY_SET_COLORKEY 24
 typedef struct {
   uint32_t x11; // The raw x11 color
   uint16_t r,g,b;
 } mp_colorkey_t;
 
 #define VOCTRL_XOVERLAY_SET_WIN 23
 typedef struct {
   int x,y;
   int w,h;
 } mp_win_t;
 
+#if 0
+#define VOCTRL_SET_VIDEO_HEADER 40
+typedef struct {
+   int id;
+   void *data;
+} mp_video_header_t;
+#endif
+
 #define VO_TRUE      1
 #define VO_FALSE     0
 #define VO_ERROR    -1
 #define VO_NOTAVAIL -2
 #define VO_NOTIMPL  -3
 
 #define VOFLAG_FULLSCREEN         0x01
 #define VOFLAG_MODESWITCHING      0x02
 #define VOFLAG_SWSCALE            0x04
 #define VOFLAG_FLIPPING           0x08
 #define VOFLAG_HIDDEN             0x10  //< Use to create a hidden window
 #define VOFLAG_STEREO             0x20  //< Use to create a stereo-capable window
 #define VOFLAG_DEPTH              0x40  //< Request a depth buffer
 #define VOFLAG_XOVERLAY_SUB_VO 0x10000
 
 typedef struct vo_info_s
 {
     /* driver name ("Matrox Millennium G200/G400" */
     const char *name;
     /* short name (for config strings) ("mga") */
     const char *short_name;
     /* author ("Aaron Holtzman <aholtzma@ess.engr.uvic.ca>") */
     const char *author;
     /* any additional comments */
     const char *comment;
 } vo_info_t;
 
 typedef struct vo_functions_s
 {
     const vo_info_t *info;
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/vf_mp.c ffmpeg-2.4.6-Helix/libavfilter/vf_mp.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavfilter/vf_mp.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavfilter/vf_mp.c	2015-04-12 13:47:40.736643384 +0200
@@ -95,60 +95,64 @@
     {IMGFMT_440P,  AV_PIX_FMT_YUV440P},
 
     {IMGFMT_420A,  AV_PIX_FMT_YUVA420P},
 
     {IMGFMT_420P16_LE,  AV_PIX_FMT_YUV420P16LE},
     {IMGFMT_420P16_BE,  AV_PIX_FMT_YUV420P16BE},
     {IMGFMT_422P16_LE,  AV_PIX_FMT_YUV422P16LE},
     {IMGFMT_422P16_BE,  AV_PIX_FMT_YUV422P16BE},
     {IMGFMT_444P16_LE,  AV_PIX_FMT_YUV444P16LE},
     {IMGFMT_444P16_BE,  AV_PIX_FMT_YUV444P16BE},
 
     // YUVJ are YUV formats that use the full Y range and not just
     // 16 - 235 (see colorspaces.txt).
     // Currently they are all treated the same way.
     {IMGFMT_YV12,  AV_PIX_FMT_YUVJ420P},
     {IMGFMT_422P,  AV_PIX_FMT_YUVJ422P},
     {IMGFMT_444P,  AV_PIX_FMT_YUVJ444P},
     {IMGFMT_440P,  AV_PIX_FMT_YUVJ440P},
 
 #if FF_API_XVMC
     {IMGFMT_XVMC_MOCO_MPEG2, AV_PIX_FMT_XVMC_MPEG2_MC},
     {IMGFMT_XVMC_IDCT_MPEG2, AV_PIX_FMT_XVMC_MPEG2_IDCT},
 #endif /* FF_API_XVMC */
 
     {IMGFMT_VDPAU_MPEG1,     AV_PIX_FMT_VDPAU_MPEG1},
     {IMGFMT_VDPAU_MPEG2,     AV_PIX_FMT_VDPAU_MPEG2},
     {IMGFMT_VDPAU_H264,      AV_PIX_FMT_VDPAU_H264},
     {IMGFMT_VDPAU_WMV3,      AV_PIX_FMT_VDPAU_WMV3},
     {IMGFMT_VDPAU_VC1,       AV_PIX_FMT_VDPAU_VC1},
     {IMGFMT_VDPAU_MPEG4,     AV_PIX_FMT_VDPAU_MPEG4},
+    {IMGFMT_VDPAU_MSMPEG4V1, AV_PIX_FMT_VDPAU_MSMPEG4V1},
+    {IMGFMT_VDPAU_MSMPEG4V2, AV_PIX_FMT_VDPAU_MSMPEG4V2},
+    {IMGFMT_VDPAU_MSMPEG4V3, AV_PIX_FMT_VDPAU_MSMPEG4V3},
+    {IMGFMT_VDPAU_MSMPEG4V4, AV_PIX_FMT_VDPAU_MSMPEG4V4},
     {0, AV_PIX_FMT_NONE}
 };
 
 extern const vf_info_t ff_vf_info_eq2;
 extern const vf_info_t ff_vf_info_eq;
 extern const vf_info_t ff_vf_info_fspp;
 extern const vf_info_t ff_vf_info_ilpack;
 extern const vf_info_t ff_vf_info_pp7;
 extern const vf_info_t ff_vf_info_softpulldown;
 extern const vf_info_t ff_vf_info_uspp;
 
 
 static const vf_info_t* const filters[]={
     &ff_vf_info_eq2,
     &ff_vf_info_eq,
     &ff_vf_info_fspp,
     &ff_vf_info_ilpack,
     &ff_vf_info_pp7,
     &ff_vf_info_softpulldown,
     &ff_vf_info_uspp,
 
     NULL
 };
 
 /*
 Unsupported filters
 1bpp
 ass
 bmovl
 crop
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavformat/mov.c ffmpeg-2.4.6-Helix/libavformat/mov.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavformat/mov.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavformat/mov.c	2015-11-23 22:43:43.337005138 +0100
@@ -2461,74 +2461,76 @@
                    "filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n",
                    st->index, dref->path, dref->dir, dref->filename,
                    dref->volume, dref->nlvl_from, dref->nlvl_to);
     } else {
         sc->pb = c->fc->pb;
         sc->pb_is_copied = 1;
     }
 
     if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
         if (!st->sample_aspect_ratio.num &&
             (st->codec->width != sc->width || st->codec->height != sc->height)) {
             st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /
                                              ((double)st->codec->width * sc->height), INT_MAX);
         }
 
 #if FF_API_R_FRAME_RATE
         if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))
             av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                       sc->time_scale, sc->stts_data[0].duration, INT_MAX);
 #endif
     }
 
     // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.
     if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&
         TAG_IS_AVCI(st->codec->codec_tag)) {
         ret = ff_generate_avci_extradata(st);
         if (ret < 0)
             return ret;
     }
 
+#if 0
     switch (st->codec->codec_id) {
 #if CONFIG_H261_DECODER
     case AV_CODEC_ID_H261:
 #endif
 #if CONFIG_H263_DECODER
     case AV_CODEC_ID_H263:
 #endif
 #if CONFIG_MPEG4_DECODER
     case AV_CODEC_ID_MPEG4:
 #endif
         st->codec->width = 0; /* let decoder init width/height */
         st->codec->height= 0;
         break;
     }
+#endif
 
     /* Do not need those anymore. */
     av_freep(&sc->chunk_offsets);
     av_freep(&sc->stsc_data);
     av_freep(&sc->sample_sizes);
     av_freep(&sc->keyframes);
     av_freep(&sc->stts_data);
     av_freep(&sc->stps_data);
     av_freep(&sc->rap_group);
 
     return 0;
 }
 
 static int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)
 {
     int ret;
     c->itunes_metadata = 1;
     ret = mov_read_default(c, pb, atom);
     c->itunes_metadata = 0;
     return ret;
 }
 
 static int mov_read_custom_2plus(MOVContext *c, AVIOContext *pb, int size)
 {
     int64_t end = avio_tell(pb) + size;
     uint8_t *key = NULL, *val = NULL;
     int i;
     AVStream *st;
     MOVStreamContext *sc;
 
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/arm/intmath.h ffmpeg-2.4.6-Helix/libavutil/arm/intmath.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/arm/intmath.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavutil/arm/intmath.h	2015-04-12 13:47:40.736643384 +0200
@@ -34,68 +34,69 @@
 static av_always_inline av_const unsigned av_clip_uint8_arm(int a)
 {
     unsigned x;
     __asm__ ("usat %0, #8,  %1" : "=r"(x) : "r"(a));
     return x;
 }
 
 #define av_clip_int8 av_clip_int8_arm
 static av_always_inline av_const int av_clip_int8_arm(int a)
 {
     int x;
     __asm__ ("ssat %0, #8,  %1" : "=r"(x) : "r"(a));
     return x;
 }
 
 #define av_clip_uint16 av_clip_uint16_arm
 static av_always_inline av_const unsigned av_clip_uint16_arm(int a)
 {
     unsigned x;
     __asm__ ("usat %0, #16, %1" : "=r"(x) : "r"(a));
     return x;
 }
 
 #define av_clip_int16 av_clip_int16_arm
 static av_always_inline av_const int av_clip_int16_arm(int a)
 {
     int x;
     __asm__ ("ssat %0, #16, %1" : "=r"(x) : "r"(a));
     return x;
 }
-
+/*
 #define av_clip_uintp2 av_clip_uintp2_arm
 static av_always_inline av_const unsigned av_clip_uintp2_arm(int a, int p)
 {
     unsigned x;
     __asm__ ("usat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p));
     return x;
 }
+*/
 
 #define av_sat_add32 av_sat_add32_arm
 static av_always_inline int av_sat_add32_arm(int a, int b)
 {
     int r;
     __asm__ ("qadd %0, %1, %2" : "=r"(r) : "r"(a), "r"(b));
     return r;
 }
 
 #define av_sat_dadd32 av_sat_dadd32_arm
 static av_always_inline int av_sat_dadd32_arm(int a, int b)
 {
     int r;
     __asm__ ("qdadd %0, %1, %2" : "=r"(r) : "r"(a), "r"(b));
     return r;
 }
 
 #endif /* HAVE_ARMV6_INLINE */
 
 #if HAVE_ASM_MOD_Q
 
 #define av_clipl_int32 av_clipl_int32_arm
 static av_always_inline av_const int32_t av_clipl_int32_arm(int64_t a)
 {
     int x, y;
     __asm__ ("adds   %1, %R2, %Q2, lsr #31  \n\t"
              "itet   ne                     \n\t"
              "mvnne  %1, #1<<31             \n\t"
              "moveq  %0, %Q2                \n\t"
              "eorne  %0, %1,  %R2, asr #31  \n\t"
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/pixdesc.c ffmpeg-2.4.6-Helix/libavutil/pixdesc.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/pixdesc.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavutil/pixdesc.c	2015-04-13 00:01:51.923015490 +0200
@@ -888,60 +888,84 @@
     [AV_PIX_FMT_VDPAU_MPEG1] = {
         .name = "vdpau_mpeg1",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
     [AV_PIX_FMT_VDPAU_MPEG2] = {
         .name = "vdpau_mpeg2",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
     [AV_PIX_FMT_VDPAU_WMV3] = {
         .name = "vdpau_wmv3",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
     [AV_PIX_FMT_VDPAU_VC1] = {
         .name = "vdpau_vc1",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
     [AV_PIX_FMT_VDPAU_MPEG4] = {
         .name = "vdpau_mpeg4",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V1] = {
+        .name = "vdpau_msmpegv1",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V2] = {
+        .name = "vdpau_msmpegv2",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V3] = {
+        .name = "vdpau_msmpegv3",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V4] = {
+        .name = "vdpau_msmpegv4",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
 #endif
     [AV_PIX_FMT_RGB48BE] = {
         .name = "rgb48be",
         .nb_components = 3,
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
             { 0, 5, 1, 0, 15 },       /* R */
             { 0, 5, 3, 0, 15 },       /* G */
             { 0, 5, 5, 0, 15 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_BE,
     },
     [AV_PIX_FMT_RGB48LE] = {
         .name = "rgb48le",
         .nb_components = 3,
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
             { 0, 5, 1, 0, 15 },       /* R */
             { 0, 5, 3, 0, 15 },       /* G */
             { 0, 5, 5, 0, 15 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
     [AV_PIX_FMT_RGBA64BE] = {
         .name = "rgba64be",
         .nb_components = 4,
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/pixfmt.h ffmpeg-2.4.6-Helix/libavutil/pixfmt.h
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/pixfmt.h	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavutil/pixfmt.h	2015-04-12 14:14:54.595200300 +0200
@@ -85,60 +85,64 @@
     AV_PIX_FMT_XVMC_MPEG2_IDCT,
 #define AV_PIX_FMT_XVMC AV_PIX_FMT_XVMC_MPEG2_IDCT
 #endif /* FF_API_XVMC */
     AV_PIX_FMT_UYVY422,   ///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
     AV_PIX_FMT_UYYVYY411, ///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
     AV_PIX_FMT_BGR8,      ///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
     AV_PIX_FMT_BGR4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
     AV_PIX_FMT_BGR4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
     AV_PIX_FMT_RGB8,      ///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
     AV_PIX_FMT_RGB4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
     AV_PIX_FMT_RGB4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
     AV_PIX_FMT_NV12,      ///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
     AV_PIX_FMT_NV21,      ///< as above, but U and V bytes are swapped
 
     AV_PIX_FMT_ARGB,      ///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
     AV_PIX_FMT_RGBA,      ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
     AV_PIX_FMT_ABGR,      ///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
     AV_PIX_FMT_BGRA,      ///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
 
     AV_PIX_FMT_GRAY16BE,  ///<        Y        , 16bpp, big-endian
     AV_PIX_FMT_GRAY16LE,  ///<        Y        , 16bpp, little-endian
     AV_PIX_FMT_YUV440P,   ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
     AV_PIX_FMT_YUVJ440P,  ///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of PIX_FMT_YUV440P and setting color_range
     AV_PIX_FMT_YUVA420P,  ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
 #if FF_API_VDPAU
     AV_PIX_FMT_VDPAU_H264,///< H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_MPEG1,///< MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_MPEG2,///< MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_WMV3,///< WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_VC1, ///< VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
+    AV_PIX_FMT_VDPAU_MSMPEG4V1,
+    AV_PIX_FMT_VDPAU_MSMPEG4V2,
+    AV_PIX_FMT_VDPAU_MSMPEG4V3,
+    AV_PIX_FMT_VDPAU_MSMPEG4V4,
 #endif
     AV_PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
     AV_PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
 
     AV_PIX_FMT_RGB565BE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
     AV_PIX_FMT_RGB565LE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
     AV_PIX_FMT_RGB555BE,  ///< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0
     AV_PIX_FMT_RGB555LE,  ///< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0
 
     AV_PIX_FMT_BGR565BE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
     AV_PIX_FMT_BGR565LE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
     AV_PIX_FMT_BGR555BE,  ///< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1
     AV_PIX_FMT_BGR555LE,  ///< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1
 
     AV_PIX_FMT_VAAPI_MOCO, ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
     AV_PIX_FMT_VAAPI_IDCT, ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
     AV_PIX_FMT_VAAPI_VLD,  ///< HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
 
     AV_PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
     AV_PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
     AV_PIX_FMT_YUV422P16LE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
     AV_PIX_FMT_YUV422P16BE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
     AV_PIX_FMT_YUV444P16LE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
     AV_PIX_FMT_YUV444P16BE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
 #if FF_API_VDPAU
     AV_PIX_FMT_VDPAU_MPEG4,  ///< MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
 #endif
     AV_PIX_FMT_DXVA2_VLD,    ///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
 
     AV_PIX_FMT_RGB444LE,  ///< packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0
diff -U 30 -H -b -w -B -E -d -t -r -N -x '*.rej' -x '*.log' -x '*.fate' -x '*~' -x '*.orig' -x '*.d' -x '*.pc' -x '*.mak' -x '*.texi' -x config.h -x avconfig.h -x ffversion.h -- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/utils.c ffmpeg-2.4.6-Helix/libavutil/utils.c
--- ffmpeg_test/FFmpeg-2.4.6-Helix/libavutil/utils.c	2015-01-17 19:09:02.000000000 +0100
+++ ffmpeg-2.4.6-Helix/libavutil/utils.c	2015-04-12 14:15:47.823521373 +0200
@@ -9,61 +9,61 @@
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #include "config.h"
 #include "avutil.h"
 #include "avassert.h"
 #include "samplefmt.h"
 #include "pixdesc.h"
 
 /**
  * @file
  * various utility functions
  */
 
 #include "libavutil/ffversion.h"
 const char av_util_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
 
 unsigned avutil_version(void)
 {
     static int checks_done;
     if (checks_done)
         return LIBAVUTIL_VERSION_INT;
 
-    av_assert0(AV_PIX_FMT_VDA_VLD == 81); //check if the pix fmt enum has not had anything inserted or removed by mistake
+    //av_assert0(AV_PIX_FMT_VDA_VLD == 81); //check if the pix fmt enum has not had anything inserted or removed by mistake
     av_assert0(AV_SAMPLE_FMT_DBLP == 9);
     av_assert0(AVMEDIA_TYPE_ATTACHMENT == 4);
     av_assert0(AV_PICTURE_TYPE_BI == 7);
     av_assert0(LIBAVUTIL_VERSION_MICRO >= 100);
     av_assert0(HAVE_MMX2 == HAVE_MMXEXT);
 
     av_assert0(((size_t)-1) > 0); // C guarantees this but if false on a platform we care about revert at least b284e1ffe343d6697fb950d1ee517bafda8a9844
 
     if (av_sat_dadd32(1, 2) != 5) {
         av_log(NULL, AV_LOG_FATAL, "Libavutil has been build with a broken binutils, please upgrade binutils and rebuild\n");
         abort();
     }
 
     if (llrint(1LL<<60) != 1LL<<60) {
         av_log(NULL, AV_LOG_ERROR, "Libavutil has been linked to a broken llrint()\n");
     }
 
 #if defined(ASSERT_LEVEL) && ASSERT_LEVEL > 0
     ff_check_pixfmt_descriptors();
 #endif
     checks_done = 1;
     return LIBAVUTIL_VERSION_INT;
 }
 
 const char *avutil_configuration(void)
 {
     return FFMPEG_CONFIGURATION;
 }
 
 const char *avutil_license(void)
